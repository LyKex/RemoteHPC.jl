function flagstring(f, v)
    out = ""
    if !occursin("-", f)
        if length(f) == 1
            out *= "-$f "
        else
            out *= "--$f="
        end
    else
        if occursin("--", f)
            out *= "$f="
        else
            out *= "$f "
        end
    end
    if !(v isa AbstractString) && length(v) > 1
        for v_ in v
            out *="$v_ "
        end
    else
        out *= "$v "
    end
    return out
end

function Base.print(io::IO, e::Exec)
    direxec = joinpath(e.dir, e.exec)
    print(io, "$direxec ")
    for (f, v) in e.flags
        print(io, flagstring(f, v))
    end
end

function Base.print(io::IO, c::Calculation)
    print(io, c.exec)
    if !isempty(c.infile)
        print(io, "< $(c.infile)")
    end
    if !isempty(c.outfile)
        print(io, " > $(c.outfile)")
    end
end

function exports_string(e::Environment)
    out = ""
    for (f, v) in e.exports
        out *= "export $f=$v\n"
    end
    return out
end

preamble_string(e::Environment) = "$(e.preamble)\n"

function preamble_string(e::SlurmEnvironment)
    out = ""
    for (f, v) in e.params 
        out *= "#SBATCH $(flagstring(f, v))\n"
    end
    out *= "$(e.preamble)\n"
    return out
end

postamble_string(e::Environment) = "$(e.postamble)\n"

function script(e::Environment, calcs::Vector{Calculation})
    out = "#!/bin/bash\n"
    out *= "# Generated by RemoteHPC\n"
    out *= "# Environment: name=$(e.name) type=$(typeof(e))\n"
    out *= preamble_string(e)
    out *= exports_string(e)
    modules = String[]
    for c in calcs
        for m in c.exec.modules
            if !(m ∈ modules)
                push!(modules, m)
            end
        end
    end
    if !isempty(modules)
        out *= "module load $(join(modules, " "))\n"
    end
    for c in calcs
        out *= c.run ? "" : "#"
        out *= c.exec.parallel ? "$(e.parallel_exec)" : ""
        names = c.exec.parallel ? "$(e.parallel_exec.name) $(c.exec.name)" : c.exec.name
        out *= "$c #exec: names=[$names] modules=["
        for m in c.exec.modules[1:end-1]
            out *= "$m "
        end
        out *= "$(c.exec.modules[end])]\n"
    end
    out *= postamble_string(e)
    return out
end

function parse_flag(str)
    f, v = split(replace(replace(str, "-" => ""), "=" => " "))
    tp = Meta.parse(v)
    return f, tp isa Symbol ? v : tp
end 

function parse_script(str::AbstractString)
    lines = filter(!isempty, split(str, "\n"))
    name = match(r"name=(\w+)", lines[3]).captures[1]
    type = replace(match(r"type=([\w\.]+)", lines[3]).captures[1], "RemoteHPC." => "")
    
    export_r = r"export (\w+)=(.+)"
    exports = Dict()
    processed_ids = Int[1, 2, 3]
    for (il, l) in enumerate(lines)
        m = match(export_r, l)
        if m !== nothing
            tp = Meta.parse(m.captures[2])
            exports[m.captures[1]] = tp isa Symbol ? m.captures[2] : tp
            push!(processed_ids, il)
        end
    end
    mid = findfirst(x -> occursin("module load", x), lines)
    if mid !== nothing
        modules = string.(split(lines[mid])[3:end])
        push!(processed_ids, mid) 
    else
        modules = String[]
    end
    execlines = String[]
    lastexec = 0
    firstexec = 0
    for (il, l) in enumerate(lines)
        if occursin("#exec", l)
            if firstexec == 0
                firstexec = il
            end
            push!(execlines, l)
            push!(processed_ids, il)
            lastexec = il
        end
    end
    preamble = ""
    postamble = ""
    for (il, l) in enumerate(lines)
        if !(il ∈ processed_ids)
            if il < firstexec
                preamble *= l * "\n"
            elseif il > lastexec
                postamble *= l * "\n"
            end
        end
    end

    parallel_exec = Exec()
    calcs = Calculation[]
    for l in execlines
        run = l[1] != '#'
        m = match(r"> ([\w\.]+)", l)
        outfile = m === nothing ? "" : m.captures[1]
        m = match(r"< (.+) >", l)
        infile = m === nothing ? "" : m.captures[1]
        m = match(r"#exec: names=\[(.+)\]\s\w+", l)
        names = m === nothing ? "" : split(m.captures[1])
        m = match(r"modules=\[(.+)\]", l)
        modules = m=== nothing ?  String[] : split(m.captures[1])
        l = split(l, "<")[1]
        ereg = r"(?<![-=])\b([a-zA-Z/\.]+)\b"
        m = match(ereg, l)
        execs_matches = RegexMatch[m]
        while m !== nothing
            m = match(ereg, l, m.offset + length(m.match))
            if m !== nothing
                push!(execs_matches, m)
            end
        end

        execs = Exec[]
        for (i, e) in enumerate(execs_matches)
            dir, exec = splitdir(e.captures[1])
            r = i == length(execs_matches) ? range(e.offset+length(e.match), length(l), step=1) : range(e.offset+length(e.match), execs_matches[i+1].offset, step=1)
            s = split(replace(l[r], "=" => " "))
            curvals = nothing
            flags = Dict()
            curflag = ""
            for v in s
                if occursin("-", v)
                    if curvals !== nothing && !isempty(curflag)
                       flags[curflag] = curvals
                       curvals = nothing
                    end
                    n = length(filter(isequal('-'), v))
                    curflag = replace(v, "-" => "")
                    
                    if length(curflag) > 1 && n == 1
                        curflag = "-" * curflag
                    end
                else
                    tp = Meta.parse(v)
                    t = tp isa Symbol ? v : tp 
                    if curvals === nothing
                       curvals = t
                    elseif curvals isa Vector
                       push!(curvals, t)
                    else
                       curvals = [curvals, t]
                    end
                end
            end
            if !isempty(curflag)
                flags[curflag] = curvals
            end
            push!(execs, Exec(exec=exec, dir=dir, flags=flags, name=names[i], modules=modules))
        end
        if length(execs) > 1
            for e in execs[2:end]
               e.parallel = true
            end
            parallel_exec = execs[1]
        end
        push!(calcs, Calculation(execs[end], infile, outfile, run))
    end
    typ = Meta.parse(type)
    empty!(parallel_exec.modules)
    params, preamble = eval(:(generate_params($typ, $preamble)))
    return eval(:($(typ)(name=$name, exports=$exports, preamble=$preamble, params=$params, parallel_exec=$parallel_exec))), calcs
end
